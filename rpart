# ----------------------------
# 1️⃣ Install and import packages
# ----------------------------
# pip install rpy2   # Uncomment if rpy2 not installed

import pandas as pd
import rpy2.robjects as ro
from rpy2.robjects import pandas2ri
from rpy2.robjects.packages import importr

# Activate automatic conversion between pandas and R dataframes
pandas2ri.activate()

# Import rpart package from R
rpart = importr('rpart')

# ----------------------------
# 2️⃣ Prepare the dataset
# ----------------------------
# Filter only SME-reviewed claims for pattern discovery
df_audit = df[df['sme_selected']==1].copy()

# Define categorical columns (handled as factors in R)
categorical_cols = ['discharge_statuscode','aprdrgcode','diag1','proc1']
for c in categorical_cols:
    df_audit[c] = df_audit[c].astype('category')  # convert to categorical

# Convert the filtered dataframe to R dataframe
rdf = pandas2ri.py2rpy(df_audit)

# ----------------------------
# 3️⃣ Build the decision tree in R
# ----------------------------
# Formula: target ~ all features (categorical + continuous)
formula = ro.Formula('finding_target ~ discharge_statuscode + aprdrgcode + diag1 + proc1 + age + totalpaidamount + lengthofstay + cc_count + mcc_count + soi_indicator')

# Train the tree (used only for pattern discovery)
# maxdepth=4, minbucket=50 can be adjusted for interpretability
tree = rpart.rpart(
    formula,
    data=rdf,
    method="class",  # classification tree
    control=rpart.rpart_control(maxdepth=4, minbucket=50)
)

# ----------------------------
# 4️⃣ Apply tree to full dataset to get leaf IDs
# ----------------------------
rdf_full = pandas2ri.py2rpy(df)  # convert full dataset to R

# Predict leaf/node assignment for each row (where each row falls in tree)
leaf_ids = ro.r['predict'](tree, rdf_full, type="where")

# Convert leaf IDs back to pandas
leaf_ids = pandas2ri.rpy2py(leaf_ids)
df['leaf_id'] = leaf_ids  # assign leaf_id to original dataset

# ----------------------------
# 5️⃣ Compute overall metrics per leaf
# ----------------------------
metrics = df.groupby('leaf_id').agg(
    total_cnt=('finding_target','size'),        # total claims in leaf
    sme_cnt=('sme_selected','sum'),            # number of SME-reviewed claims
    find_cnt=('finding_target','sum'),         # number of findings
    total_savings=('savings','sum')            # total savings in leaf
).reset_index()

# Hit rate (SME-reviewed only)
metrics['hitrate'] = metrics['find_cnt'] / metrics['sme_cnt']

# SME selection rate (how many claims were reviewed by SME)
metrics['sme_sel_rate'] = metrics['sme_cnt'] / metrics['total_cnt']

# Support (proportion of all claims)
metrics['support'] = metrics['total_cnt'] / len(df)

# Lift (pattern hit rate relative to overall baseline)
baseline = df[df['sme_selected']==1]['finding_target'].mean()
metrics['lift'] = metrics['hitrate'] / baseline

# Missed opportunity (# of claims not reviewed by SME)
metrics['missed_cnt'] = metrics['total_cnt'] - metrics['sme_cnt']

# Expected missed findings
metrics['expected_missed_findings'] = metrics['missed_cnt'] * metrics['hitrate']

# Expected savings for missed claims
# multiply hitrate by savings of unreviewed claims
df = df.merge(metrics[['leaf_id','hitrate']], on='leaf_id', how='left')
df['expected_savings'] = df['hitrate'] * df['savings']
missed_df = df[df['sme_selected']==0]
expected_savings_leaf = missed_df.groupby('leaf_id')['expected_savings'].sum().reset_index()
metrics = metrics.merge(expected_savings_leaf, on='leaf_id', how='left')
metrics['expected_savings'] = metrics['expected_savings'].fillna(0)

# ----------------------------
# 6️⃣ Extract human-readable rules per leaf
# ----------------------------
# Using rpart.rules (from R package rpart.plot)
rpart_plot = importr('rpart.plot')  # make sure rpart.plot installed in R

# Export rules to R string
rules_str = ro.r['capture.output'](rpart_plot.rpart.rules(tree))
rules_list = list(rules_str)  # convert to Python list
# rules_list now contains strings describing each leaf rule

# Optional: combine rules with metrics
# Create a DataFrame mapping leaf_id to rules
leaf_rules = pd.DataFrame({'leaf_rule': rules_list})
leaf_rules['leaf_id'] = metrics['leaf_id'].values  # align leaf_id
metrics = metrics.merge(leaf_rules, on='leaf_id', how='left')

# ----------------------------
# 7️⃣ Client-specific metrics
# ----------------------------
client_metrics = []
for client in df['clientname'].unique():
    df_client = df[df['clientname']==client].copy()
    client_leaf = df_client.groupby('leaf_id').agg(
        total_cnt=('finding_target','size'),
        sme_cnt=('sme_selected','sum'),
        find_cnt=('finding_target','sum')
    ).reset_index()
    client_leaf = client_leaf[client_leaf.sme_cnt>0]  # avoid divide by zero
    client_leaf['hitrate'] = client_leaf['find_cnt']/client_leaf['sme_cnt']
    client_leaf['sme_sel_rate'] = client_leaf['sme_cnt']/client_leaf['total_cnt']
    client_leaf['support'] = client_leaf['total_cnt']/len(df_client)
    baseline_client = df_client[df_client['sme_selected']==1]['finding_target'].mean()
    client_leaf['lift'] = client_leaf['hitrate']/baseline_client
    client_leaf['missed_cnt'] = client_leaf['total_cnt'] - client_leaf['sme_cnt']
    client_leaf['expected_missed_findings'] = client_leaf['missed_cnt'] * client_leaf['hitrate']

    # Expected savings for missed claims per client
    df_client = df_client.merge(client_leaf[['leaf_id','hitrate']], on='leaf_id', how='left')
    df_client['expected_savings'] = df_client['hitrate'] * df_client['savings']
    missed_client = df_client[df_client['sme_selected']==0]
    expected_savings_client = missed_client.groupby('leaf_id')['expected_savings'].sum().reset_index()
    client_leaf = client_leaf.merge(expected_savings_client, on='leaf_id', how='left')
    client_leaf['expected_savings'] = client_leaf['expected_savings'].fillna(0)
    
    client_leaf['clientname'] = client
    client_metrics.append(client_leaf)

client_metrics = pd.concat(client_metrics)

# ----------------------------
# ✅ 8️⃣ Outputs
# ----------------------------
# Overall metrics
print(metrics)

# Client-specific metrics
print(client_metrics)

# Human-readable rules for reference
print(metrics[['leaf_id','leaf_rule']])
