# ----------------------------
# 1️⃣ Import packages
# ----------------------------
import pandas as pd
import numpy as np
from rpy2.robjects import pandas2ri, r
from rpy2.robjects.packages import importr

pandas2ri.activate()
rpart = importr('rpart')

# ----------------------------
# 2️⃣ Build the tree
# ----------------------------
# Assume df has all your columns, including substatus_find, substatus_nofind, sme_selected
formula = r['as.formula']('finding_target ~ discharge_statuscode + aprdrgcode + diag1 + proc1 + age + totalpaidamount + lengthofstay + cc_count + mcc_count + soi_indicator')
tree = rpart.rpart(formula, data=pandas2ri.py2rpy(df), method="class", control=rpart.rpart_control(maxdepth=4, minbucket=50))

# ----------------------------
# 3️⃣ Extract all nodes from tree
# ----------------------------
frame = r['as.data.frame'](tree.rx2('frame'))
frame = pandas2ri.rpy2py(frame)
frame = frame.reset_index().rename(columns={'index':'node_id'})

# Add leaf flag
frame['is_leaf'] = frame['var'] == '<leaf>'

# Compute parent_id and level
def compute_parent_level(node_id):
    node_id = int(node_id)
    if node_id == 1:
        return None, 1
    level = int(np.floor(np.log2(node_id)))
    parent_id = node_id // 2
    return parent_id, level

frame[['parent_id','level']] = frame['node_id'].apply(lambda x: pd.Series(compute_parent_level(x)))

# ----------------------------
# 4️⃣ Compute leaf_rule for each node
# ----------------------------
# We'll use rpart.rules to extract rules per leaf and map to nodes
r['library']('rpart.plot')
rules_list = list(r['rpart_rules'](tree))
# Map rules to node_ids (leaf nodes only)
leaf_rules = pd.DataFrame({'leaf_rule': rules_list, 'node_id': frame[frame['is_leaf']]['node_id'].values})

# For internal nodes, we can leave rule as empty or approximate with variable
frame = frame.merge(leaf_rules, on='node_id', how='left')
frame['leaf_rule'] = frame['leaf_rule'].fillna(frame['var'].replace('<leaf>',''))

# ----------------------------
# 5️⃣ Compute overall metrics for all nodes
# ----------------------------
metrics_list = []

for node_id in frame['node_id']:
    # Filter rows in df that pass through this node
    # We'll use the 'where' output to map rows to leaves first, then include all parent nodes
    # Predict leaf node for all rows
    leaf_ids = np.array(r['predict'](tree, pandas2ri.py2rpy(df), type="where"))
    df_temp = df.copy()
    df_temp['leaf_id'] = leaf_ids
    
    # A row passes through a node if its leaf_id is a descendant of that node
    # In rpart, node numbering: left child = 2*node, right child = 2*node + 1
    def is_descendant(leaf, node):
        node = int(node)
        leaf = int(leaf)
        while leaf > 1:
            if leaf == node:
                return True
            leaf = leaf // 2
        return leaf == node
    
    df_node = df_temp[[i for i in df_temp.index if is_descendant(df_temp.loc[i,'leaf_id'], node_id)]]
    
    total_cnt = len(df_node)
    sme_cnt = df_node['sme_selected'].sum()
    find_cnt = df_node['substatus_find'].sum()
    nofind_cnt = df_node['substatus_nofind'].sum()
    total_savings = df_node['savings'].sum()
    
    hitrate = find_cnt / (find_cnt + nofind_cnt) if (find_cnt + nofind_cnt) > 0 else 0
    sme_sel_rate = sme_cnt / total_cnt if total_cnt > 0 else 0
    missed_cnt = total_cnt - sme_cnt
    expected_missed_findings = missed_cnt * hitrate
    expected_savings = total_savings * hitrate
    support = total_cnt / len(df)
    
    baseline = df[df['sme_selected']==1]['substatus_find'].mean()
    lift = hitrate / baseline if baseline>0 else 0
    
    metrics_list.append({
        'node_id': node_id,
        'parent_id': frame.loc[frame['node_id']==node_id,'parent_id'].values[0],
        'level': frame.loc[frame['node_id']==node_id,'level'].values[0],
        'is_leaf': frame.loc[frame['node_id']==node_id,'is_leaf'].values[0],
        'leaf_rule': frame.loc[frame['node_id']==node_id,'leaf_rule'].values[0],
        'total_cnt': total_cnt,
        'sme_cnt': sme_cnt,
        'find_cnt': find_cnt,
        'nofind_cnt': nofind_cnt,
        'hitrate': hitrate,
        'sme_sel_rate': sme_sel_rate,
        'missed_cnt': missed_cnt,
        'expected_missed_findings': expected_missed_findings,
        'expected_savings': expected_savings,
        'support': support,
        'lift': lift
    })

overall_metrics_all_nodes = pd.DataFrame(metrics_list).sort_values(['level','node_id']).reset_index(drop=True)

# ----------------------------
# 6️⃣ Client-specific metrics per node
# ----------------------------
clients = df['clientname'].unique()
client_metrics_list = []

for client in clients:
    df_client = df[df['clientname']==client]
    baseline_client = df_client[df_client['sme_selected']==1]['substatus_find'].mean()
    
    client_metrics_temp = []
    for node_id in frame['node_id']:
        # Determine rows passing through node
        df_node = df_client[[i for i in df_client.index if is_descendant(df_client.loc[i,'leaf_id'], node_id)]]
        
        total_cnt = len(df_node)
        sme_cnt = df_node['sme_selected'].sum()
        find_cnt = df_node['substatus_find'].sum()
        nofind_cnt = df_node['substatus_nofind'].sum()
        total_savings = df_node['savings'].sum()
        
        hitrate = find_cnt / (find_cnt + nofind_cnt) if (find_cnt + nofind_cnt) > 0 else 0
        sme_sel_rate = sme_cnt / total_cnt if total_cnt > 0 else 0
        missed_cnt = total_cnt - sme_cnt
        expected_missed_findings = missed_cnt * hitrate
        expected_savings = total_savings * hitrate
        support = total_cnt / len(df_client) if len(df_client)>0 else 0
        lift = hitrate / baseline_client if baseline_client>0 else 0
        
        client_metrics_temp.append({
            'clientname': client,
            'node_id': node_id,
            'parent_id': frame.loc[frame['node_id']==node_id,'parent_id'].values[0],
            'level': frame.loc[frame['node_id']==node_id,'level'].values[0],
            'is_leaf': frame.loc[frame['node_id']==node_id,'is_leaf'].values[0],
            'leaf_rule': frame.loc[frame['node_id']==node_id,'leaf_rule'].values[0],
            'total_cnt': total_cnt,
            'sme_cnt': sme_cnt,
            'find_cnt': find_cnt,
            'nofind_cnt': nofind_cnt,
            'hitrate': hitrate,
            'sme_sel_rate': sme_sel_rate,
            'missed_cnt': missed_cnt,
            'expected_missed_findings': expected_missed_findings,
            'expected_savings': expected_savings,
            'support': support,
            'lift': lift
        })
    
    client_metrics_list.append(pd.DataFrame(client_metrics_temp))

client_metrics_all_nodes = pd.concat(client_metrics_list, ignore_index=True).sort_values(['clientname','level','node_id']).reset_index(drop=True)

# ----------------------------
# ✅ Outputs
# ----------------------------
print("Overall metrics (all nodes/splits):")
print(overall_metrics_all_nodes)

print("\nClient-specific metrics (all nodes/splits):")
print(client_metrics_all_nodes)
