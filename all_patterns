 ----------------------------
# 1️⃣ Install and import packages
# ----------------------------
# pip install rpy2   # Uncomment if rpy2 not installed

import pandas as pd
import rpy2.robjects as ro
from rpy2.robjects import pandas2ri
from rpy2.robjects.packages import importr

# Activate automatic conversion between pandas and R dataframes
pandas2ri.activate()

# Import rpart package from R
rpart = importr('rpart')

# ----------------------------
# 2️⃣ Prepare the dataset
# ----------------------------
# Filter only SME-reviewed claims for tree building
df_audit = df[df['sme_selected']==1].copy()

# Define categorical columns (treated as factors in R)
categorical_cols = ['discharge_statuscode','aprdrgcode','diag1','proc1']
for c in categorical_cols:
    df_audit[c] = df_audit[c].astype('category')

# Convert to R dataframe
rdf = pandas2ri.py2rpy(df_audit)

# ----------------------------
# 3️⃣ Build the decision tree in R
# ----------------------------
# Use finding_target as target, all features as predictors
formula = ro.Formula(
    'finding_target ~ discharge_statuscode + aprdrgcode + diag1 + proc1 + age + totalpaidamount + lengthofstay + cc_count + mcc_count + soi_indicator'
)

# Train tree (adjust maxdepth/minbucket for more splits if needed)
tree = rpart.rpart(
    formula,
    data=rdf,
    method="class",
    control=rpart.rpart_control(maxdepth=5, minbucket=10, minsplit=20)
)

# ----------------------------
# 4️⃣ Apply tree to full dataset to get leaf IDs
# ----------------------------
rdf_full = pandas2ri.py2rpy(df)  # full data

# Predict terminal node (leaf) for each row
leaf_ids = ro.r['predict'](tree, rdf_full, type="where")

# Convert leaf IDs to pandas
leaf_ids = pandas2ri.rpy2py(leaf_ids)
df['leaf_id'] = leaf_ids

# ----------------------------
# 5️⃣ Compute overall metrics per leaf (pattern)
# ----------------------------
metrics = df.groupby('leaf_id').agg(
    total_cnt=('finding_target','size'),       # all claims in leaf
    sme_cnt=('sme_selected','sum'),           # SME-reviewed claims
    find_cnt=('finding_target','sum'),        # findings
    nofind_cnt=(lambda x: ((df.loc[x.index,'sme_selected']==1) & (df.loc[x.index,'finding_target']==0)).sum()),  # non-findings
    total_savings=('savings','sum')           # total savings
).reset_index()

# Hit rate among SME-reviewed
metrics['hitrate'] = metrics['find_cnt'] / metrics['sme_cnt']

# SME selection rate for leaf
metrics['sme_sel_rate'] = metrics['sme_cnt'] / metrics['total_cnt']

# Support (proportion of all claims)
metrics['support'] = metrics['total_cnt'] / len(df)

# Lift relative to overall baseline
baseline = df[df['sme_selected']==1]['finding_target'].mean()
metrics['lift'] = metrics['hitrate'] / baseline

# Missed opportunities
metrics['missed_cnt'] = metrics['total_cnt'] - metrics['sme_cnt']
metrics['expected_missed_findings'] = metrics['missed_cnt'] * metrics['hitrate']

# Expected savings for missed claims
df = df.merge(metrics[['leaf_id','hitrate']], on='leaf_id', how='left')
df['expected_savings'] = df['hitrate'] * df['savings']
missed_df = df[df['sme_selected']==0]
expected_savings_leaf = missed_df.groupby('leaf_id')['expected_savings'].sum().reset_index()
metrics = metrics.merge(expected_savings_leaf, on='leaf_id', how='left')
metrics['expected_savings'] = metrics['expected_savings'].fillna(0)

# ----------------------------
# 6️⃣ Extract human-readable rules per leaf
# ----------------------------
rpart_plot = importr('rpart.plot')  # ensure installed in R
rules_str = ro.r['capture.output'](rpart_plot.rpart.rules(tree))
rules_list = list(rules_str)

# Map leaf rules to metrics
leaf_rules = pd.DataFrame({'leaf_rule': rules_list})
leaf_rules['leaf_id'] = metrics['leaf_id'].values
metrics = metrics.merge(leaf_rules, on='leaf_id', how='left')

# ----------------------------
# 7️⃣ Client-specific metrics
# ----------------------------
client_metrics = []
for client in df['clientname'].unique():
    df_client = df[df['clientname']==client].copy()
    client_leaf = df_client.groupby('leaf_id').agg(
        total_cnt=('finding_target','size'),
        sme_cnt=('sme_selected','sum'),
        find_cnt=('finding_target','sum'),
        nofind_cnt=(lambda x: ((df_client.loc[x.index,'sme_selected']==1) & (df_client.loc[x.index,'finding_target']==0)).sum())
    ).reset_index()
    client_leaf = client_leaf[client_leaf.sme_cnt>0]  # avoid divide by zero
    client_leaf['hitrate'] = client_leaf['find_cnt'] / client_leaf['sme_cnt']
    client_leaf['sme_sel_rate'] = client_leaf['sme_cnt'] / client_leaf['total_cnt']
    client_leaf['support'] = client_leaf['total_cnt'] / len(df_client)
    baseline_client = df_client[df_client['sme_selected']==1]['finding_target'].mean()
    client_leaf['lift'] = client_leaf['hitrate'] / baseline_client
    client_leaf['missed_cnt'] = client_leaf['total_cnt'] - client_leaf['sme_cnt']
    client_leaf['expected_missed_findings'] = client_leaf['missed_cnt'] * client_leaf['hitrate']

    # Expected savings per client
    df_client = df_client.merge(client_leaf[['leaf_id','hitrate']], on='leaf_id', how='left')
    df_client['expected_savings'] = df_client['hitrate'] * df_client['savings']
    missed_client = df_client[df_client['sme_selected']==0]
    expected_savings_client = missed_client.groupby('leaf_id')['expected_savings'].sum().reset_index()
    client_leaf = client_leaf.merge(expected_savings_client, on='leaf_id', how='left')
    client_leaf['expected_savings'] = client_leaf['expected_savings'].fillna(0)

    client_leaf['clientname'] = client
    client_metrics.append(client_leaf)

client_metrics = pd.concat(client_metrics)

# ----------------------------
# 8️⃣ Outputs
# ----------------------------
# Overall metrics table
print(metrics)

# Client-specific metrics table
print(client_metrics)

# Human-readable rules for reference
print(metrics[['leaf_id','leaf_rule']])
